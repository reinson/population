<!DOCTYPE html>
<head>

    <style>

        .x.axis path.domain {
            display: none
        }
        .hidden {
            display: none
        }

        text {
            font-family: "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", Geneva, Verdana, sans-serif;
            fill: #696969;
        }

        .bornIn {

            font-size: 25px;
            font-style: normal;
            font-variant: normal;
            font-weight: 500;
            line-height: 15.4px;
        }

    </style>

    <meta charset="utf-8">
    <script src="//d3js.org/d3.v4.min.js"></script>

</head>
<script>

    var margin = {top: 40, right: 75, bottom: 120, left: 50};

    var width = 800 - margin.right - margin.left,
    height = 540 - margin.top - margin.bottom;

    var x = d3.scaleLinear()
        .domain([1923,2016])
        .range([0, width]);

    var y = d3.scaleLinear()
        .range([height, 0]);

    var area = d3.area()
        .x(function(d,i) { return x(d.data.Aasta); })
        .y0(function(d) { return y(d[0]); })
        .y1(function(d) { return y(d[1]); });

    var stack = d3.stack()
       // .keys(["apples", "bananas", "cherries", "dates"])
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetWiggle );

    var xAxis = d3.axisBottom()
        .scale(x);

    var yAxis = d3.axisRight()
        .scale(y);

    var color = d3.interpolateRainbow;

    function draw(error,data) {

        // (1) Transform data:
        var nested = d3.nest()
                .key(function (d) {
                    return d.Sugu
                })
                .entries(data);

        var keys = d3.keys(data[0]).filter(function (d) {
            return ["Sugu", "Vanus teadmata", "Kokku", "Aasta"].indexOf(d) === -1;
        });

        data = stack.keys(keys)(nested[0].values);

        var y_min = d3.min(data[0], function (d) {
            return d[0]
        });
        var y_max = d3.max(data[data.length - 1], function (d) {
            return d[1]
        });
        y.domain([y_min, y_max]);

        // (2) Create svg
        var svg = d3.select("body").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // (3) Create linear gradients for colored paths
        var defs = svg.append("defs");

        var gradientColors = d3.range(0, 1.01, 0.04).map(function (d) {
                    return color(d)
                }),
                offsetPercentages = d3.range(-100, 101, 8).map(function (d, i) {
                    return {
                        p: d,
                        color: gradientColors[i % 25]
                    }
                });

        var gradientOffset = data.map(function (_, i) {
            return offsetPercentages.map(function (d) {
                return {
                    p: d.p + i * 5.26,
                    color: d.color
                }
            });
        });

        defs.selectAll("linearGradient").data(gradientOffset)
                .enter()
                .append("linearGradient")
                .attr("id", function (_, i) {
                    return "lg" + i
                })
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%")
                .each(function (grad_data) {
                    var linearGradient = d3.select(this);
                    linearGradient.selectAll("stop").data(grad_data)
                            .enter().append("stop")
                            .attr("offset", function (d) {
                                return d.p + "%";
                            })
                            .attr("stop-color", function (d) {
                                return d.color;
                            });
                });

        // (4) Create pahts
        svg.selectAll("path")
                .data(data)
                .enter().append("path")
                .attr("d", area)
                .style("fill", function (_, i) {
                    return "url(#lg" + i + " )"
                })
                .on("mouseover", mouseOver)
                .on("mousemove", mouseMove)
                .on("mouseout", mouseOut);

        // (5) Create labels and guides
        var ageRangeLabel = svg.append("text").attr("x", -40).attr("class", "hidden"),
            yearLabel = svg.append("text").attr("class", "hidden"),
            yearLine = svg.append("line").attr("x1", 100).attr("x2", 100).attr("y1", 20).attr("y2", 400)
                        .attr("stroke-width", "2px").attr("stroke", "white").attr("class", "hidden")
                        .attr("opacity", 0.6).style("pointer-events", "none"),

            yearPopulationLabel = svg.append("text").attr("class", "hidden").text("tere").style("font-size", "25px")
                                    .attr("x", 0).attr("y", 20)
                                    .style("text-anchor", "start"),

            missingDataBox = svg.append("rect")
                    .attr("x", x(1939)).attr("y", 50)
                    .attr("width", x(1950) - x(1939)).attr("height", "300") // kirjutada eraldi funktsioon k√µrguse jaoks
                    .attr("opacity", 0.5).attr("fill", "white")
                    .on("mouseover", function () {
                        yearLabel.text("missing data").classed("hidden", false).attr("x", x(1939))
                                .attr("y", 50)
                    });

        svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (height + 5) + ")")
                .call(xAxis);

        // (6) Create legend box
        var legendBox = svg.append("g").attr("transform", "translate(0," + (height + 60) + ")");

        defs.append("linearGradient")
                .attr("id", "legend_lg")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%")
                .selectAll("stop")
                .data(d3.range(0, 101, 4).map(function (d) {
                            return {
                                p: d + "%",
                                color: color(d / 100)
                            }
                        })
                ).enter().append("stop")
                .attr("offset", function (d) {
                    return d.p
                })
                .attr("stop-color", function (d) {
                    return d.color
                });

        legendBox.append("rect").style("fill", "url(#legend_lg)")
                .attr("width", width)
                .attr("height", 20)
                .attr("x", 0)
                .attr("y", 10);

        var boxAxis = d3.axisBottom().scale(x.copy().domain([1830, 2015]));

        legendBox.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0,30)")
                .call(boxAxis);

        legendBox.append("text").text("Birth years").attr("x", width / 2)
                .style("text-anchor", "middle")
                .classed("bornIn", true);

        // (7) Mouse over functionality
        function mouseOver(d) {
            d3.select(this).attr("opacity", 0.75);
            ageRangeLabel.text(d.key)
                    .attr("y", function () {
                            return y((d[0][1] + d[0][0]) / 2) + 4
                        })
                    .classed("hidden", false)
        }

        function mouseMove(d) {
            var mouse = d3.mouse(this),
                mouseYear = Math.floor(x.invert(mouse[0])),
                yearData = nested[0].values.filter(function (d) {
                    return d.Aasta == mouseYear;
                }),
                stackMin = data[0].filter(function (d) { // for finding bottom of the yearLine
                    return d.data.Aasta == mouseYear;
                })[0][0],
                stackMax = data[data.length - 1].filter(function (d) { // for finding the top of the yearLine
                    return d.data.Aasta == mouseYear;
                })[0][1];

            yearLabel.text(mouseYear)
                    .attr("x", x(mouseYear))
                    .attr("y", y(stackMax) - 10)
                    .classed("hidden", false);

            yearLine.attr("x1", x(mouseYear)).attr("x2", x(mouseYear))
                    .attr("y1", y(stackMax)).attr("y2", y(stackMin))
                    .classed("hidden", false);

            var population = yearData[0].Kokku.toString();
            yearPopulationLabel.text("Population of " + d3.format(",d")(population)).classed("hidden", false);
        }

        function mouseOut(d) {
            d3.select(this).attr("opacity", 1);
            ageRangeLabel.classed("hidden", true);
            yearLine.classed("hidden", true);
            yearLabel.classed("hidden", true);
            yearPopulationLabel.classed("hidden", true)
        }
    }

    function type(row) {
        d3.keys(row).forEach(function(d){
            if (d != "Sugu"){
                row[d] = +row[d];
            }
        });
        return row;
    }

    d3.tsv("RV021.csv")
            .row(type)
            .get(draw);


</script>