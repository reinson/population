<!DOCTYPE html>
<head>

    <style>

        .x.axis path.domain {
            display: none
        }
        .hidden {
            display: none
        }
        .sparkWrapper text{
            text-anchor: middle;
        }
        text {
            font-family: "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", Geneva, Verdana, sans-serif;
            fill: #696969;
        }



        .bornIn {

            font-size: 25px;
            font-style: normal;
            font-variant: normal;
            font-weight: 500;
            line-height: 15.4px;
        }

    </style>

    <meta charset="utf-8">
    <script src="//d3js.org/d3.v4.min.js"></script>

</head>
<script>

    var margin = {top: 40, right: 170, bottom: 120, left: 50, between: 30};

    var width = 800 - margin.right - margin.left,
    height = 480 - margin.top - margin.bottom;

    var x = d3.scaleLinear()
        .domain([1923,2040])
        .range([0, width]);

    var y = d3.scaleLinear()
        .range([height, 0]);

    var area = d3.area()
        .x(function(d,i) { return x(d.data.Aasta); })
        .y0(function(d) { return y(d[0]); })
        .y1(function(d) { return y(d[1]); });

    var stack = d3.stack()
       // .keys(["apples", "bananas", "cherries", "dates"])
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetWiggle );

    var xAxis = d3.axisBottom()
        .scale(x);

    var yAxis = d3.axisRight()
        .scale(y);

    var color = d3.interpolateRainbow;

    var areaX = d3.scaleLinear().domain([0,120000]);
    var areaY = d3.scalePoint();

    var areaLine = d3.area()
        .curve(d3.curveCardinal)
        .x0(0)
        .x1(function(d,i) { return areaX(d.value); })
        .y(function(d) { return areaY(d.key); });

    var sparkYLocal = d3.local();

    var sparkX = d3.scaleLinear().domain([1923,2040]).range([0,100]);



    function draw(error,data) {

        // (1) Transform data:
        var nested = d3.nest()
                .key(function (d) {
                    return d.Sugu
                })
                .entries(data);

        var ageGroups = d3.keys(data[0]).filter(function (d) {
            return ["Sugu", "Kokku", "Aasta"].indexOf(d) === -1;
        });

        data = stack.keys(ageGroups)(nested[0].values);

        var y_min = d3.min(data[0], function (d) {
            return d[0]
        });
        var y_max = d3.max(data[data.length - 1], function (d) {
            return d[1]
        });
        y.domain([y_min, y_max]);

        // (2) Create svg
        var svg = d3.select("body").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // (3) Create linear gradients for colored paths
        var defs = svg.append("defs");

        var gradientColors = d3.range(0, 1.01, 0.04).map(function (d) {
                    return color(d)
                }),
                offsetPercentages = d3.range(-100, 101, 8).map(function (d, i) {
                    return {
                        p: d,
                        color: gradientColors[i % 25]
                    }
                });

        var gradientOffset = data.map(function (_, i) {
            return offsetPercentages.map(function (d) {
                return {
                    p: d.p + i * 5.26,
                    color: d.color
                }
            });
        });

        defs.selectAll("linearGradient").data(gradientOffset)
                .enter()
                .append("linearGradient")
                .attr("id", function (_, i) {
                    return "lg" + i
                })
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%")
                .each(function (grad_data) {
                    var linearGradient = d3.select(this);
                    linearGradient.selectAll("stop").data(grad_data)
                            .enter().append("stop")
                            .attr("offset", function (d) {
                                return d.p + "%";
                            })
                            .attr("stop-color", function (d) {
                                return d.color;
                            });
                });

        // (4) Create pahts
        svg.append("g").attr("class","pathWrapper")
                .selectAll("path")
                .data(data)
                .enter().append("path")
                .attr("d", area)
                .style("fill", function (_, i) {
                    return "url(#lg" + i + " )"
                })
                .on("mouseover", mouseOver)
                .on("mousemove", mouseMove)
                .on("mouseout", mouseOut);

        // (5) Create labels and guides
        var ageRangeLabel = svg.append("text").attr("x", -40).attr("class", "hidden"),
            yearLabel = svg.append("text").attr("class", "hidden"),
            yearLine = svg.append("line").attr("x1", 100).attr("x2", 100).attr("y1", 20).attr("y2", 400)
                        .attr("stroke-width", "2px").attr("stroke", "white").attr("class", "hidden")
                        .attr("opacity", 0.6).style("pointer-events", "none"),

            yearPopulationLabel = svg.append("text").attr("class", "hidden").text("tere").style("font-size", "25px")
                                    .attr("x", 0).attr("y", 20)
                                    .style("text-anchor", "start"),

            missingDataBox = svg.append("rect")
                    .attr("x", x(1939)).attr("y", 50)
                    .attr("width", x(1950) - x(1939)).attr("height", "300") // kirjutada eraldi funktsioon kÃµrguse jaoks
                    .attr("opacity", 0.5).attr("fill", "white")
                    .on("mouseover", function () {
                        yearLabel.text("missing data").classed("hidden", false).attr("x", x(1939))
                                .attr("y", 40)
                    });

        var areaG = svg.append("g");

        svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (height + 5) + ")")
                .call(xAxis);

        // (6) Create legend box
        var legendBox = svg.append("g").attr("transform", "translate(0," + (height + 60) + ")");

        defs.append("linearGradient")
                .attr("id", "legend_lg")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%")
                .selectAll("stop")
                .data(d3.range(0, 101, 4).map(function (d) {
                            return {
                                p: d + "%",
                                color: color(d / 100)
                            }
                        })
                ).enter().append("stop")
                .attr("offset", function (d) {
                    return d.p
                })
                .attr("stop-color", function (d) {
                    return d.color
                });

        legendBox.append("rect").style("fill", "url(#legend_lg)")
                .attr("width", width)
                .attr("height", 20)
                .attr("x", 0)
                .attr("y", 10);

        var boxAxis = d3.axisTop().scale(x.copy().domain([1830, 2015]));

        legendBox.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0,10)")
                .call(boxAxis);

        legendBox.append("text").text("Birth years").attr("x", width / 2).attr("y",52)
                .style("text-anchor", "middle")
                .classed("bornIn", true);

        var areaLocationInfo = {
            x: width + margin.between,
            y: 250, //y(stackLineRange(data,2015).max),
            height: 130,//y(stackLineRange(data,2015).max),
            width: margin.right - margin.between
        };

      //  draw_area(nested[0]);

        var populationSize = nested[0].values.map(function(d){
            return {
                x: d.Aasta,
                y: d.Kokku
            }});

        var averageAgeData = nested[0].values.map(function(d){
            var values = filterAgeGroups(d)[0];
            var numerator = d3.sum(values, function(d){
                                return d3.mean(d.key.split("-")
                                            .map(function(d){return d=="85+" ? 90 : +d})
                                                ) * d.value;
                            });
            var denominator = d3.sum(values, function(d){return d.value});
            return {
                x: d.Aasta,
                y: numerator/denominator
            }
        });

        var retiredToWorkers = nested[0].values.map(function(d){
            var values = filterAgeGroups(d)[0];
            var retiredSum = d3.sum(values, function(d){
                return +d.key.split("-")[0] >= 65 ?  d.value : d.key =="85+" ? d.value : 0;
            });
            var workersSum = d3.sum(values, function(d){
                var rangeStart = +d.key.split("-")[0];
                if (rangeStart < 65 && rangeStart >= 20){
                    return d.value
                }
                return 0;
            });

            return {x: d.Aasta,
                    y: workersSum / retiredSum
            }
        });
        console.log(retiredToWorkers);

        var sparksData = [
                        {
                            values: populationSize,
                            name: "Population size"
                        },
                        {
                            values: averageAgeData,
                            name: "Average age"
                        },
                        {
                            values: retiredToWorkers,
                            name: "Workers to retired"
                        }
                    ];
        draw_sparklines(sparksData);

        updateSparks(2016);


        // (7) Mouse over functionality
        function mouseOver(d) {
            d3.select(this).attr("opacity", 0.75);
            ageRangeLabel.text(d.key)
                    .attr("y", function () {
                            return y((d[0][1] + d[0][0]) / 2) + 4
                        })
                    .classed("hidden", false)
        }

        function mouseMove(d) {
            var mouse = d3.mouse(this),
                mouseYear = Math.floor(x.invert(mouse[0])),
                yearData = nested[0].values.filter(function (d) {
                    return d.Aasta == mouseYear;
                })[0],
                stackRange = stackLineRange(data,mouseYear);

            updateSparks(mouseYear);

            yearLabel.text(mouseYear)
                    .attr("x", x(mouseYear))
                    .attr("y", y(stackRange.max) - 10)
                    .classed("hidden", false);

            yearLine.attr("x1", x(mouseYear)).attr("x2", x(mouseYear))
                    .attr("y1", y(stackRange.max)).attr("y2", y(stackRange.min))
                    .classed("hidden", false);

        /*    var population = yearData.Kokku.toString();
            yearPopulationLabel.text("Population of " + d3.format(",d")(population)).classed("hidden", false);*/

            var newData = filterAgeGroups(yearData);

            areaG.select("path").data(newData).transition().duration(500).attr("d",areaLine)
        }

        function mouseOut(d) {
            d3.select(this).attr("opacity", 1);
            ageRangeLabel.classed("hidden", true);
            yearLine.classed("hidden", true);
            yearLabel.classed("hidden", true);
            yearPopulationLabel.classed("hidden", true)
        }

        function stackLineRange(data,year){
            var stackMin = data[0].filter(function (d) { // for finding bottom of the yearLine
                    return d.data.Aasta == year;
                })[0][0],
                stackMax = data[data.length - 1].filter(function (d) { // for finding the top of the yearLine
                    return d.data.Aasta == year;
                })[0][1];
            return {min: stackMin, max: stackMax}
        }

        function draw_sparklines(data){
            var xExtent = d3.extent(data[0].values, function(d){return d.x}),
                sparkY = d3.scaleLinear().range([20,0]),
                sparkLine = d3.line()
                    .curve(d3.curveCardinal)
                    .x(function(d){return sparkX(d.x)})
                    .y(function(d){return sparkY(d.y)});

           svg.selectAll(".spark").data(data).enter().append("g").attr("class","sparkWrapper")
               .attr("transform",function(d,i){return "translate("+ (width + margin.between) +"," + (i*130 + 25) + ")"  })
               .each(function(sparkData,i){
                   var sparkG = d3.select(this);

                   sparkG.append("text").text(sparkData.name)
                           .attr("transform","translate(50,-15)");

                   sparkG.append("text").attr("class","sparkValue").attr("transform","translate(50,45)").text("1230567");

                   var yExtent = d3.extent(sparkData.values, function(d){return d.y});
                   sparkY.domain(yExtent);

                   sparkYLocal.set(this,sparkY.copy());

                   sparkG.selectAll("path").data([sparkData.values]).enter().append("path")
                           .attr("d",sparkLine).style("fill","none").attr("stroke","black");

                   sparkG.append("circle").attr("r",2).attr("fill","red").attr("class","sparkDot");

               });
        }

        function updateSparks(year){
            var activeValues = sparksData.map(function(d){
                return d.values.filter(function(d){return d.x==year})[0].y;
            });

            svg.selectAll(".sparkValue").data(activeValues).text(function(d){return d3.format(",d")(d)});

            svg.selectAll(".sparkWrapper").each(function(d,i){
                d3.select(this).select("circle")
                        .attr("cx",sparkX(year))
                        .attr("cy",sparkYLocal.get(this)(activeValues[i]));
            })

        }

        function filterAgeGroups(yearData){
            return [d3.entries(yearData).filter(function(d){return ageGroups.indexOf(d.key)!= -1})]
        }

    } // draw

    function type(row) {
        d3.keys(row).forEach(function(d){
            if (d != "Sugu"){
                row[d] = +row[d];
            }
        });
        return row;
    }

    d3.csv("RV021.csv")
            .row(type)
            .get(draw);


</script>